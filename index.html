<html>
<head>
    <title>Genealogy</title>
    <script src='https://d3js.org/d3.v4.min.js'></script>
    <script src='https://dagrejs.github.io/project/graphlib/latest/graphlib.js'></script>
    <script src='https://dagrejs.github.io/project/dagre/latest/dagre.js'></script>
    <script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.js"></script>
<style>

.node circle {
  fill: #fff;
  stroke: red;
  stroke-width: 3px;
}

.node text {
  font: 12px "Futura";
}

.link {
  fill: none;
  stroke: red;
  stroke-width: 2px;
  opacity: 0.5;
}

.name {
  font-size: 8px
}

.university {
  font-size: 4px 
}

.tag text{
    font-size: 42px;
    opacity: 0.5;
    fill: red;
    font-family: "Futura";
}

svg {
  border-style: solid;
  border-color: green;
}


text {
  font-weight: 300;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 14px;
}

.node rect {
  stroke: #999;
  fill: #fff;
  stroke-width: 1.5px;
}

.edgePath path {
  stroke: #333;
  stroke-width: 1.5px;
}

</style>
</head>
<body>
<script>
    var width = 3000,
        height = 2500;
    var margin = {top: 20, right: 90, bottom: 30, left: 90};
    

    var svgContainer = d3.select("body")
            .append("svg")
            .attr('width', width)
            .attr('height', height);
    var svg = svgContainer.append("g")
        .attr("transform", "translate(" + 0 + "," + 0 + ")");



    


    var treemap = d3.tree().size([height, width]);
    
    var i = 0,
        duration = 750,
        root;


    function clean(root) {
        if(root.children) {
            root.children = root.children.filter(function(child) {
                return !isNaN(parseInt(child.year));
            })
            root.children.forEach(clean);
        }
    }

    function vh(v) {
        var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        
        return (v * h) / 100;
    }

    function vw(v) {
        var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        
        return (v * w) / 100;
    }

    d3.json("nodes.json", function(error, nodes) {
        d3.json("edges.json", function(error, edges) {

            var g = new dagre.graphlib.Graph();

            g.setGraph({});
            g.setDefaultEdgeLabel(function() { return {}; });


            var entries = Object.entries(nodes);


            entries = entries.filter(function(entry){
                var value = entry[1];
                return !(value.year == "" || value.name == "" || value.school == "");
            });

            

            entries.forEach(function([key, value]){
                if(value){
                    g.setNode(key, value);
                }
            });

            edges.forEach(function(edge){                
                if(g.hasNode(edge.target) && g.hasNode(edge.source)){
                    g.setEdge(edge.target, edge.source);
                }
            })

            

            dagre.layout(g);

            console.log(graphlib.json.write(g));
            console.log(g);
            //renderDagre(g);

            var xs = g.nodes().map(function(node) {
                var label = g.node(node);
                return label.x;
            });

            var ys = g.nodes().map(function(node) {
                var label = g.node(node);
                return label.y;
            });

            console.log(Math.min(...xs));
            console.log(Math.min(...ys));

            console.log(Math.max(...xs));
            console.log(Math.max(...ys));


            var nodez = g.nodes().map(function(node) {
                var label = g.node(node);

                label.id = node;
                return label;
            });

            

            var maxX = Math.max(...xs);
            var maxY = Math.max(...ys);


            var years = nodez.map(function(d){ return parseInt(d.year) })
                       .filter(function(year) { return Number.isInteger(year) });

            var min = Math.min(...years);
            var max = Math.max(...years);

            var xs = g.nodes().map(function(node) {
                var label = g.node(node);
                return label.x;
            });
            maxX = Math.max(...xs);

            var y = d3.scaleLinear()
                  .domain([min, max])
                  .range([0, height]);

            nodez.forEach(function(d){ d.y = y(d.year) });

            var links = g.edges().map(function(edge) {
                var v = edge.v;
                var w = edge.w;

                var link = {};

                var source = g.node(v);
                var target = g.node(w);

                link.source = {x:source.x, y:source.y};
                link.target = {x:target.x, y:target.y};

                return link;
            });


            renderD3(maxX, maxY, nodez, links)
        });
    });

    function renderD3(maxX, maxY, nodes, links){
        var y = d3.scaleLinear()
                  .domain([0, maxX])
                  .range([0, height]);

        var x = d3.scaleLinear()
                  .domain([0, maxY])
                  .range([0, width]);

        var node = svg.selectAll('g.node')
            .data(nodes, function(d) { return d.id });

        var nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr("transform", function(d) {
                return "translate(" + x(+d.x) + "," + y(+d.y) + ")";
            });

        var container = nodeEnter.append("a")
            .attr("xlink:href", function(d){ return "https://www.genealogy.math.ndsu.nodak.edu/id.php?id=" + d.id })
            .attr("target", "_blank");

        var text = container.append('text')
            .attr("x", function(d) {
                return  0;
            })
            .attr("text-anchor", function(d) {
                return "start";
            })


        text.append('tspan')
            .attr('class', 'name')
            .text(function(d) { return d.name + " " + d.year})
            .attr('x', 0);
            ;

        text.append('tspan')
            .attr('class', 'university')
            .text(function(d) { return d.school })
            .attr('dy', '1em')
            .attr('x', 0);



        // Update the links...
        var link = svg.selectAll('path.link')
            .data(links);

        // Enter any new links at the parent's previous position.
        var linkEnter = link.enter().insert('path', "g")
            .attr("class", "link")
            .attr('d', function(d){
                return diagonal(d.source, d.target)
            });


        function diagonal(s, d) {
            path = `M ${x(s.x)} ${y(s.y)}
                    C ${(x(s.x) + x(d.x)) / 2} ${y(d.y)},
                      ${(x(s.x) + x(d.x)) / 2} ${y(s.y)},
                      ${x(d.x)} ${y(d.y)}`
            return path
        }

    }

    function renderDagre(g){
        // Create the renderer
        var render = new dagreD3.render();
        
        // Set up an SVG group so that we can translate the final graph.
        var svg = d3.select("body").append("svg")
            .attr('width', width)
            .attr('height', height);
            svgGroup = svg.append("g");
        
        // Run the renderer. This is what draws the final graph.
        render(d3.select("svg g"), g);
        
        // Center the graph
        var xCenterOffset = (svg.attr("width") - g.graph().width) / 2;
        svgGroup.attr("transform", "translate(" + xCenterOffset + ", 20)");
        svg.attr("height", g.graph().height + 40);


        // Update the links...
        var link = svg.selectAll('path.link')
            .data(links, function(d) { return d.id; });

        // Enter any new links at the parent's previous position.
        var linkEnter = link.enter().insert('path', "g")
            .attr("class", "link")
            .attr('d', function(d){
                var o = {x: source.y0, y: source.x0}
                return diagonal(o, o)
            });


        svg.call(d3.zoom()
            .scaleExtent([1, 5])
            .on("zoom", zoom));

        function zoom() {
            svg.attr("transform", d3.event.transform);
        }

        // Creates a curved (diagonal) path from parent to the child nodes
        
    }

    /**
    d3.json("genealogy.json", function(error, data) {
        console.log(data);

        clean(data)

        root = d3.hierarchy(data, function(d) { return d.children; });
        root.x0 = height / 2;
        root.y0 = 0;

        //root.children.forEach(collapse);

        update(root);
    });
    **/

    // Collapse the node and all it's children
    function collapse(d) {
      if(d.children) {
        d._children = d.children
        d._children.forEach(collapse)
        d.children = null
      }
    }

    function myRange(start, edge, step) {
        // If only 1 number passed make it the edge and 0 the start
        if (arguments.length === 1) {
            edge = start;
            start = 0;
        }
      
        // Validate edge/start
        edge = edge || 0;
        step = step || 1;
      
        // Create array of numbers, stopping before the edge
        let arr = [];
        for (arr; (edge - start) * step > 0; start += step) {
            arr.push(start);
        }
        return arr;
    }

    function update(source) {
        var treeData = treemap(root);

        // Compute the new tree layout.
        var nodes = treeData.descendants(),
            links = treeData.descendants().slice(1);
        // Normalize for fixed-depth.

        var years = nodes.map(function(d){ return parseInt(d.data.year) });


        var min = Math.min(...years);
        var max = Math.max(...years);





        
        


        var range = max - min;

        var step = range / treeData.height;

        var x = d3.scaleLinear()
                  .domain([min, max])
                  .range([0, height]);
        nodes.forEach(function(d){ d.y = x(parseInt(d.data.year));
                                   d.x = d.x + 100; });





        var tags = myRange(min, max, 100);

        console.log(tags);
        

        svg.selectAll('g')
            .data(tags)
            .enter()
            .append('g')
            .attr('class', 'tag')
            .attr("transform", function(d) {
                return "translate(0," + x(d) + ")";
            })
            .append('text')
            .text(function(d) {
                return  d});


        // Update the nodes...
        var node = svg.selectAll('g.node')
            .data(nodes, function(d) { return d.id });

        var nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr("transform", function(d) {
                return "translate(" + source.y0 + "," + source.x0 + ")";
            });


        var container = nodeEnter.append("a")
            .attr("xlink:href", function(d){ return "https://www.genealogy.math.ndsu.nodak.edu/id.php?id=" + d.data.gen_id })
            .attr("target", "_blank");


        // Add Circle for the nodes
        container.append('circle')
            .attr('class', 'node')
            .attr('r', 10)
            .style("fill", function(d) {
                return d._children ? "red" : "#fff";
        })
        .on('click', click);


              // Add labels for the nodes
        var text = container.append('text')
            .attr("x", function(d) {
                return  0;
            })
            .attr("text-anchor", function(d) {
                return "start";
            })


        text.append('tspan')
            .attr('class', 'name')
            .text(function(d) { return d.data.name })
            .attr('x', 0);
            ;

        text.append('tspan')
            .attr('class', 'university')
            .text(function(d) { return d.data.university })
            .attr('dy', '1em')
            .attr('x', 0);

          // UPDATE
        var nodeUpdate = nodeEnter.merge(node);

        // Transition to the proper position for the node
        nodeUpdate.transition()
            .duration(duration)
            .attr("transform", function(d) { 
                return "translate(" + d.x + "," + d.y + ")";
            });
        // Update the node attributes and style
        nodeUpdate.select('circle.node')
            .attr('r', 1e-6)
            .style("fill", function(d) {
                return d._children ? "lightsteelblue" : "#fff";
            })
            .attr('cursor', 'pointer');


        // Remove any exiting nodes
        var nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", function(d) {
                return "translate(" + source.y + "," + source.x + ")";
            })
            .remove();

        // On exit reduce the node circles size to 0
        nodeExit.select('circle')
            .attr('r', 1e-6);

        // On exit reduce the opacity of text labels
        nodeExit.select('text')
            .style('fill-opacity', 1e-6);
   
        
          // ****************** links section ***************************

        // Update the links...
        var link = svg.selectAll('path.link')
            .data(links, function(d) { return d.id; });

        // Enter any new links at the parent's previous position.
        var linkEnter = link.enter().insert('path', "g")
            .attr("class", "link")
            .attr('d', function(d){
                var o = {x: source.y0, y: source.x0}
                return diagonal(o, o)
            });

        // UPDATE
        var linkUpdate = linkEnter.merge(link);

        // Transition back to the parent element position
        linkUpdate.transition()
            .duration(duration)
            .attr('d', function(d){ return diagonal(d, d.parent) });

        // Remove any exiting links
        var linkExit = link.exit().transition()
            .duration(duration)
            .attr('d', function(d) {
                var o = {x: source.y, y: source.x}
                return diagonal(o, o)
            })
            .remove();

        // Store the old positions for transition.
        nodes.forEach(function(d){
            d.x0 = d.y;
            d.y0 = d.x;
        });

        // Creates a curved (diagonal) path from parent to the child nodes
        function diagonal(s, d) {
            path = `M ${s.x} ${s.y}
                    C ${(s.x + d.x) / 2} ${d.y},
                      ${(s.x + d.x) / 2} ${s.y},
                      ${d.x} ${d.y}`
            return path
        }

        // Toggle children on click.
        function click(d) {
          if (d.children) {
              d._children = d.children;
              d.children = null;
            } else {
              d.children = d._children;
              d._children = null;
            }
          update(d);
        }


    }
    
    svgContainer
    .call(d3.zoom()
        .scaleExtent([1, 8])
        .on("zoom", zoom));

    function zoom() {
        svg.attr("transform", d3.event.transform);
    }


</script>
</body>
</html>